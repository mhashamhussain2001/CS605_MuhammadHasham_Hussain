# -*- coding: utf-8 -*-
"""Assignment_5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l7Jl6pIBwOEyb73wI1zSAqmF17vSYDXF

# Binary Search Tree Implementation
"""

# TreeNode class creation
class TreeNode:
    def __init__(self, key, value):
        self.key = key            # Name
        self.value = value        # Phone number
        self.left = None          # Left child
        self.right = None         # Right child


# BinarySearchTree class creation
class BinarySearchTree:
    def __init__(self):
        self.root = None

    # Insert a new node
    def insert(self, name, phone_number):
        self.root = self.insert_recursive(self.root, name, phone_number)

    def insert_recursive(self, node, key, value):
        # Base case
        if node is None:
            return TreeNode(key, value)

        # Compare keys lexicographically, lower goes left, higher goes right
        if key < node.key:
            node.left = self.insert_recursive(node.left, key, value)

        elif key > node.key:
            node.right = self.insert_recursive(node.right, key, value)

        # In case the key already exists, update the phone number
        else:
            node.value = value

        return node

    # Search for a phone number by name
    def search(self, name):
        node = self.search_recursive(self.root, name)
        return node.value if node else None

    def search_recursive(self, node, key):
        if node is None or node.key == key:
            return node

        if key < node.key:
            return self.search_recursive(node.left, key)

        else:
            return self.search_recursive(node.right, key)

    # Inorder traversal (sorted output)
    def inorder_traversal(self):
        self.inorder_recursive(self.root)

    def inorder_recursive(self, node):
        if node:
            self.inorder_recursive(node.left)
            print(f"{node.key}: {node.value}")
            self.inorder_recursive(node.right)

    # Delete a node by name
    def delete(self, name):
        self.root = self.delete_recursive(self.root, name)

    def delete_recursive(self, node, key):
        if node is None:
            return node

        # Search for the node
        if key < node.key:
            node.left = self.delete_recursive(node.left, key)

        elif key > node.key:
            node.right = self.delete_recursive(node.right, key)

        else:
            # Node found â€” handle deletion cases

            # No child
            if node.left is None and node.right is None:
                return None

            # One child
            elif node.left is None:
                return node.right

            elif node.right is None:
                return node.left

            # Two children
            else:
                successor = self.find_min(node.right)
                node.key, node.value = successor.key, successor.value
                node.right = self.delete_recursive(node.right, successor.key)

        return node

    # Find the smallest node (used for deletion)
    def find_min(self, node):
        current = node
        while current.left is not None:
            current = current.left
        return current


# Test Cases
if __name__ == "__main__":
    bst = BinarySearchTree()

    # Inserting examples
    bst.insert("Hasham", "112233")
    bst.insert("Ali", "445566")
    bst.insert("Matt", "778899")

    # Searching for names
    print("Hasham:", bst.search("Hasham"))   # Output = 112233
    print("Ali:", bst.search("Ali"))         # Output = 445566

    # Name not present
    print("Aidan:", bst.search("Aidan"))   # Output = None

    # Inorder traversal (sorted output)
    print("\nInorder Traversal:")
    bst.inorder_traversal()

    # Deletion example
    print("\nDeletion of Hasham")
    bst.delete("Hasham")
    bst.inorder_traversal()
    print("\nHasham Successfully deleted")

